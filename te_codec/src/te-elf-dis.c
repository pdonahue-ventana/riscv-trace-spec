/*
 * Copyright (c) 2020 UltraSoC Technologies Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "te-elf-dis.h"


/*
 * Append one tuple to the very end of the array.
 *
 * This will grow the array's memory when required.
 *
 * Tuples may be added in any order. It is expected
 * that the array will be sorted by address order
 * once all the tuples have been inserted.
 */
static void add_one_elf_dis_tuple(
    te_elf_dis_file_t * const elf_dis,
    uint64_t const address,
    const char * const line)
{
    /* paranoia */
    assert(elf_dis);
    assert(elf_dis->num_tuples <= elf_dis->max_tuples);

    /* first, do we need to grow the array of tuples ? */
    if (elf_dis->num_tuples == elf_dis->max_tuples)
    {
        /* grow by 1024 tuples at a time (a power of 2) */
        const size_t growth = 1u << 10;
        elf_dis->max_tuples += growth;
        membuf_append(
            &elf_dis->membuf,
            growth * sizeof(te_elf_dis_tuple_t),
            NULL);
    }

    /* pointer to the first free tuple */
    te_elf_dis_tuple_t * const tuple =
        (te_elf_dis_tuple_t*)(elf_dis->membuf.data)
        + elf_dis->num_tuples;

    /* save both the fields to the first free tuple */
    tuple->address = address;
    tuple->line = strdup_or_die(line);

    /* advance to the next tuple to use */
    elf_dis->num_tuples++;
}


/*
 * comparison function used by qsort(3)
 */
static int compare_tuples(
    const void * const tuple_1,
    const void * const tuple_2)
{
    const te_elf_dis_tuple_t * const x =
        (const te_elf_dis_tuple_t*)tuple_1;
    const te_elf_dis_tuple_t * const y =
        (const te_elf_dis_tuple_t*)tuple_2;

    if (x->address == y->address)
    {
        return 0;   /* tuple_1 == tuple_2 */
    }
    else if (x->address > y->address)
    {
        return 1;   /* tuple_1 > tuple_2 */
    }
    else
    {
        return -1;  /* tuple_1 < tuple_2 */
    }
}


/*
 * This function is called to parse an entire
 * disassembly file, associated with the Elf
 * file, nominally generated by 'objdump -d'.
 *
 * It returns zero on success, and non-zero otherwise.
 */
extern int te_read_one_elf_dis_file(
    te_elf_dis_file_t * const elf_dis,
    const char * const elf_dis_name)
{
    char buff[160], line[160];
    uint64_t address;

    assert(elf_dis);
    assert(elf_dis_name);

    /* open the disassembled Elf file */
    FILE * const stream = fopen(elf_dis_name, "r");

    if (NULL == stream)     /* failed to open file ? */
    {
        return 1;   /* failed ... nothing more to do here */
    }

    /* initialize the data structures */
    memset(elf_dis, 0, sizeof(*elf_dis));
    membuf_init(&elf_dis->membuf);

    /* save the name of the Elf disassembly file */
    elf_dis->elf_dis_name = strdup_or_die(elf_dis_name);

    /* read each line in turn, extracting the required fields */
    while (fgets(buff, sizeof(buff), stream))
    {
        /*
         * Input line expected to be of the form:
         *
         *  <hex-digits> ':' '<tab>' <text> '\n'
         *
         * Only two fields: the address (<hex-digits>), and the
         * disassembler text (<text>) are required to be stored.
         */
        const int count =
            sscanf(buff, "%" PRIx64 ":\t%[^\n]", &address, line);

        /*
         * if we get successfully retrieved both fields,
         * then append them both to the array of lines.
         * ... otherwise just silently discard the whole line.
         */
        if (2 == count)
        {
            add_one_elf_dis_tuple(elf_dis, address, line);
        }
    }

    /* close the input stream */
    fclose(stream);

    /*
     * Finally, sort the array of tuples by address,
     * as it is not guaranteed that objdump will provide
     * everything in strictly ascending address order.
     *
     * This array will be accessed using a binary-chop
     * algorithm, hence it is essential that all
     * the addresses are strictly increasing!
     *
     * Assuming of course, there are at least two tuples!
     */
    if (elf_dis->num_tuples >= 2u)  /* worth sorting ? */
    {
        qsort(
            elf_dis->membuf.data,
            elf_dis->num_tuples,
            sizeof(te_elf_dis_tuple_t),
            compare_tuples);
    }

    return 0;   /* success */
}


/*
 * free all the memory associated with
 * a single te_elf_dis_file_t instance
 */
extern void te_free_one_elf_dis_file(
    te_elf_dis_file_t * const elf_dis)
{
    /* pointer to the first tuple in the array */
    te_elf_dis_tuple_t * tuple =
        (te_elf_dis_tuple_t *)(elf_dis->membuf.data);

    /* free the elf-dis filename (if there was one) */
    if (elf_dis->elf_dis_name)
    {
        free((void*)elf_dis->elf_dis_name);
    }

    /* free all the lines allocated with strdup_or_die() */
    for (size_t i=0; i<elf_dis->num_tuples; i++,tuple++)
    {
        free((void*)tuple->line);
    }

    /* finally, free the memory for the array of tuples */
    membuf_free(&elf_dis->membuf);
}


/*
 * find the exact address 'address' in the array of
 * tuples ... if it exists, return the pointer to
 * the tuple ... otherwise return NULL.
 */
extern const te_elf_dis_tuple_t * te_find_one_elf_dis_tuple(
    const te_elf_dis_file_t * const elf_dis,
    const uint64_t address)
{
    const te_elf_dis_tuple_t * const tuples =
        (te_elf_dis_tuple_t *)(elf_dis->membuf.data);

    uint64_t lo = 0;                        /* lower bound */
    uint64_t hi = elf_dis->num_tuples - 1u; /* upper bound */

    /*
     * if there are no tuples at all, then give up
     * now ... and simply return NULL.
     */
    if (!elf_dis->num_tuples)
    {
        return NULL;    /* no possible match */
    }

    /*
     * check the address is strictly inside
     * the valid range.
     */
    if ( (address < tuples[lo].address) ||
         (address > tuples[hi].address)   )
    {
        return NULL;    /* no possible match */
    }

    /*
     * perform a binary-chop algorithm to find the address.
     *
     * Note: we assume all keys are strictly ascending!
     */
    while (lo <= hi)
    {
        uint64_t mid = (lo+hi) >> 1; /* mid-point */

        if (address == tuples[mid].address)
        {
            return tuples + mid;    /* got a match */
        }
        else if (address > tuples[mid].address)
        {
            lo = mid + 1;   /* use the upper half */
        }
        else
        {
            hi = mid - 1;   /* use the lower half */
        }
    }

    return NULL;        /* no match found */
}


#if 0   /* example: my_do_custom_instruction() */
/*
 * The following is an EXAMPLE function, which calls the function
 * te_find_one_elf_dis_tuple(). This example code may be used as a
 * template to help adding support for custom RISC-V instructions.
 *
 * It will be called after the RISC-V disassembler has been invoked,
 * but before the information from the disassembler is actually used.
 *
 * Specifically this function should:
 *
 * 1) select the appropriate disassemble text line for the current
 *    custom instruction (retrieved from the elf-dis file), and
 *
 * 2) update any of the instruction decode state that the
 *    disassembler generated (e.g. opcode group) ... as appropriate.
 *    (Typically not needed for simple sequential custom instructions.)
 *
 * For non-custom instructions, then nothing needs to be done here.
 *
 * Note:
 * The function my_do_custom_instruction() should be passed to the
 * function te_open_trace_decoder().
 * The function te_read_one_elf_dis_file() should be called to parse
 * the elf-dis file (the output from 'objdump -d').
 * A pointer to an instance of the my_user_data_t structure is
 * passed to te_open_trace_decoder() (as user_data).
 */

#include "decoder-algorithm-public.h"

typedef struct
{
    /* pointer to one parsed "elf-dis" file */
    const te_elf_dis_file_t * elf_dis;
    /* ... any other user-specific context fields */
} my_user_data_t;

void my_do_custom_instruction(
    void * const user_data,
    te_decoded_instruction_t * const instr)
{
    assert(user_data);
    assert(instr);

    /* obtain pointer to "elf-dis" from user_data structure */
    my_user_data_t * const my_user_data = (my_user_data_t*)user_data;
    const te_elf_dis_file_t * const elf_dis = my_user_data->elf_dis;

    if (elf_dis)    /* parsed an elf-dis file ? */
    {
        /* address of the instruction in question */
        const te_address_t address = instr->decode.pc;

        /* is 'address' in the elf-dis file ? */
        const te_elf_dis_tuple_t * const tuple =
            te_find_one_elf_dis_tuple(elf_dis, address);

        if (tuple)  /* found a match ? */
        {
            /* use the disassembly line from the elf-dis file */
            strncpy(
                instr->line,
                tuple->line,
                sizeof(instr->line) - 1u);

            /* ensure it is always nul-terminated */
            instr->line[sizeof(instr->line) - 1u] = '\0';

            /*
             * update the "instr" structure to record
             * that this instruction is now being treated
             * as a "custom instruction", and therefore
             * the fields in instr->decode may not be
             * correct ... and specifically that if
             * instr->decode.op == rv_op_illegal that
             * may not be strictly true either!
             */
            instr->custom = true;
        }
    }
}
#endif  /* example: my_do_custom_instruction() */
